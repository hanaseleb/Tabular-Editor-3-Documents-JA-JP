---
uid: parallel-development
title: Enabling parallel development using Git and Save to Folder
author: Daniel Otykier
updated: 2021-09-30
applies_to:
  editions:
    - edition: Desktop
      none: x
    - edition: Business
    - edition: Enterprise
---

# GitとSave to Folderを使った並行開発の実現

<div style="padding:56.25% 0 0 0;position:relative;"><iframe src=https://player.vimeo.com/video/664699623? h=57bde801c7&amp;badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479 frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen style="position:absolute;top:0;left:0;width:100;height:100%;" title="Boosting productivity"></iframe></div><script src=https://player.vimeo.com/api/player.js></script>

この記事では、パラレルモデル開発（複数の開発者が同じデータモデルで並行して作業を行うこと）の原則と、その際のTabular Editorの役割について説明します。

## 前提条件

- データモデルの保存先は、以下のいずれかである必要があります。
  - SQL Server 2016（またはそれ以降） Analysis Services Tabular
  - Azure Analiticsサービス
  - Power BI Premium Capacity/Power BI Premium-per-user with [XMLA read/write enabled](https://docs.microsoft.com/en-us/power-bi/admin/service-premium-connect-tools#enable-xmla-read-write)
- チームメンバー全員がアクセスできるGitリポジトリ（オンプレミスまたはAzure DevOps、GitHubなどでホストされているもの）

## ソースコードとしてのTOM

並列開発は従来、Analysis Servicesの表形式モデルやPower BIのデータセットに実装することは困難でした（本記事では、簡潔にするため両タイプのモデルを「tabular models」と呼びます）。[Tabular Object Model:TOM](https://docs.microsoft.com/en-us/analysis-services/tom/introduction-to-the-tabular-object-model-tom-in-analysis-services-amo?view=asallproducts-allversions)で採用されているJSONベースのモデルメタデータが導入されたことで、モデルメタデータをバージョン管理に統合することは確かに容易になりました。

テキストベースのファイルフォーマットを使用することで、バージョンコントロールシステムによく含まれているさまざまなdiffツールを使用して、矛盾した変更を潔く処理することが可能になります。このような変更の衝突処理は、すべてのソースコードが多数の小さなテキストファイルに存在する従来のソフトウェア開発では非常に一般的です。このような理由から、一般的なバージョン管理システムは、変更の検出と（自動的な）競合解決を目的として、この種のファイルに最適化されています。

表計算モデルの開発では、JSONベースのTOMメタデータが「ソースコード」となります。以前のバージョンのVisual Studioで表形式モデルを開発する場合、Model.bim JSONファイルには、誰がいつ何を変更したかという情報が追加されていました。この情報は、単純にファイル内のJSONオブジェクトの追加プロパティとして保存されていました。これには問題がありました。というのも、情報が冗長であるだけでなく（ファイル自体にも、最後に編集した人や最後に編集した時間を記述したメタデータがあるため）、バージョン管理の観点からはこのメタデータには何の*意味もありません。言い換えれば、ファイルから修正メタデータをすべて削除したとしても、モデルの機能やビジネスロジックに影響を与えることなく、分析サービスにデプロイしたりPower BIにパブリッシュしたりすることができる完全に有効なTOM JSONファイルができあがります。

従来のソフトウェア開発におけるソースコードのように、このような情報がモデルのメタデータを "汚染 "することは望ましくありません。実際、バージョン管理システムでは、誰がいつ、何のために行った変更かをより詳細に見ることができるので、バージョン管理されているファイルの一部として含める理由はありません。

Tabular Editorが作られた当初は、Visual Studioで作成されたModel.bimファイルからこの情報を取り除くオプションはありませんでしたが、幸いにも最近のバージョンでは変更されました。しかし、モデルを定義するすべての「ソースコード」を含む単一の一枚岩のファイル（Model.bimファイル）を処理する必要があることに変わりはありません。

Power BIのデータセット開発者は、モデルのメタデータを含むテキストベースのファイルにアクセスすることすらできないため、さらに不利です。彼らができることは、Power BIレポートを[Power BIテンプレート(`.pbit`)ファイル](https://docs.microsoft.com/en-us/power-bi/create-reports/desktop-templates#creating-report-templates)としてエクスポートすることだけです。これは基本的に、レポートページ、データモデル定義、クエリ定義を含むZIPファイルです。バージョン管理システムの観点からするとZIPファイルはバイナリファイルであり、バイナリファイルはテキストファイルと同じように差分を取ったり、比較したり、マージしたりすることができません。このため、Power BIの開発者は、データモデルを適切にバージョン管理するために、サードパーティのツールを使用したり、手の込んだスクリプトやプロセスを考え出したりしなければなりません。

Tabular Editorは、Analysis ServicesのタブラーモデルやPower BIのデータセットにかかわらず、タブラーオブジェクトモデルから意味のあるメタデータだけを抽出する簡単な方法を提供することで、このプロセスを簡素化することを目的としています。さらに、Tabular Editorは、Save to Folder機能を使って、このメタデータを複数の小さなファイルに分割できます。

## Save to Folderとは？

前述したように、タブラーモデルのモデルメタデータは、従来は単一のモノリシックなJSONファイル（通常は**Model.bim**という名前）に格納されており、バージョン管理の統合には適していませんでした。このファイルのJSONは[Tabular Object Model (TOM)](https://docs.microsoft.com/en-us/analysis-services/tom/introduction-to-the-tabular-object-model-tom-in-analysis-services-amo?view=asallproducts-allversions)を表しているので、このファイルをより小さなピースに分解する簡単な方法であることがわかりました。TOMには、モデル内のテーブルのリスト、テーブル内のメジャーのリスト、メジャー内のアノテーションのリストなど、ほぼすべてのレベルのオブジェクトの配列が含まれています。Tabular Editorの**Save to Folder**機能を使用すると、これらの配列は単純にJSONから削除され、代わりに元の配列の各オブジェクトに対応する1つのファイルを含むサブフォルダーが生成されます。この処理は入れ子にできます。結果として、フォルダー構造になります。各フォルダーには、より小さなJSONファイルとサブフォルダーのセットが含まれ、意味的にはオリジナルのModel.bimファイルとまったく同じ情報を含んでいます。

![Save To Folder](https://docs.tabulareditor.com/images/save-to-folder.png)

個々のTOMオブジェクトを表す各ファイルの名前は、単純にオブジェクト自体の`Name`プロパティに基づいています。ルート」ファイルの名前は **Database.json** であり、そのため、フォルダーベースのストレージフォーマットを単に **Database.json** と呼ぶことがあります。

## Save to Folderを使うメリット

表形式のモデルのメタデータをフォルダーに保存することで、以下のような利点があります。

- **多くのバージョン管理システムでは、いくつかの大きなファイルよりも、複数の小さなファイルの方が適しています。** たとえば、gitは変更されたファイルのスナップショットを保存します。この理由だけでも、モデルを1つの大きなファイルとして保存するよりも、複数の小さなファイルとして表現した方が良いことを理解できます。
- テーブル、メジャー、カラムなどのリストは、Model.bimのJSONでは配列として表現されます。しかし、配列内のオブジェクトの順序は重要ではありません。モデルの開発中に、カット・アンド・ペーストの操作などにより、オブジェクトの順序が変更されることは珍しくありません。Save to Folderでは、配列オブジェクトが個別のファイルとして保存されるため、配列の変更履歴が残らず、マージコンフリクトのリスクが軽減されます。
- **別々の開発者が同じファイルを変更することはほとんどありません。** データモデルの別々の部分を開発する限り、同じファイルを変更することはほとんどなく、マージコンフリクトのリスクを減らすことができます。

## Save to Folderを使うことの欠点

現状では、タブラーモデルのメタデータをフォルダーベースのフォーマットで保存することの唯一の欠点は、このフォーマットがTabular Editorでのみ使用されることです。つまり、フォルダーベースのフォーマットからモデルのメタデータをVisual Studioに直接ロードすることはできません。その代わりに、フォルダーベースのフォーマットを一時的にModel.bimフォーマットに変換する必要がありますが、これはもちろんTabular Editorを使って行うことができます。

## Save to Folderを設定する

1つのサイズがすべてに適合することはほとんどありません。Tabular Editorには、モデルをフォルダー構造にシリアライズする方法に影響を与えるいくつかの設定オプションがあります。Tabular Editor 3では、一般的な設定は**Tools > Preferences > Save-to-folder**にあります。モデルがTabular Editorに読み込まれると、そのモデルに適用される特定の設定は、**Model > Serialization options...** で確認できます。特定のモデルに適用される設定は、モデル自体にアノテーションとして保存され、どのユーザがモデルを読み込んだり保存したりしても、同じ設定が使用されるようになっています。

![フォルダーへの保存を設定する](https://docs.tabulareditor.com/images/configuring-save-to-folder.png)

### シリアル化の設定

- 推奨される設定を使用する**。(Default: checked) これをチェックすると、Tabular Editorはモデルをフォルダー構造として初めて保存する際に、デフォルトの設定を使用します。
- **Serialize relationships on from-tables**: (Default: unchecked) これがチェックされていると、Tabular Editorはリレーションシップをモデルレベルで保存するのではなく、リレーションシップの「from-side」のテーブル（通常はファクトテーブル）にアノテーションとして保存します。これは、テーブル名が頻繁に変更されるようなモデルの初期開発段階で便利です。
- **オブジェクトのパースペクティブ・メンバーシップ情報をシリアライズする**。(デフォルト: チェックなし) これがチェックされていると、Tabular Editorは、オブジェクト（テーブル、列、階層、メジャー）がどのパースペクティブに属しているかという情報を、パースペクティブレベルではなく、そのオブジェクトのアノテーションとして保存します。これは、オブジェクト名は変更される可能性があるが、パースペクティブ名は確定している場合に便利です。
- **翻訳されたオブジェクトの翻訳をシリアライズする**。(デフォルト：チェックなし）これをチェックすると、Tabular Editorはメタデータの翻訳をカルチャレベルで保存するのではなく、翻訳可能な各オブジェクト（テーブル、カラム、階層、レベル、メジャーなど）の注釈として保存します。これは、オブジェクト名が変更される可能性がある場合に便利です。
- **Prefix file names sequentially**: (Default: unchecked) 配列メンバーのメタデータの順序（テーブルの列の順序など）を保持したい場合、これをチェックすると、Tabular Editorはファイル名の前に配列内のオブジェクトのインデックスに基づいた連続した整数を付けることができます。これは、Excelのデフォルトのドリルスルー機能を使用していて、[ドリルスルーで列を特定の順序で表示させたい](https://github.com/TabularEditor/TabularEditor/issues/46#issuecomment-297932090)場合に便利です。

> [!!! NOTE].
> 上述の設定の主な目的は、モデルのメタデータをどこにどのように保存するかを調整することで、モデル開発時に発生するマージ・コンフリクトの数を減らすことです。モデル開発の初期段階では、オブジェクトの名前が頻繁に変更されることが珍しくありません。もしモデルに既にメタデータのトランスレーションが指定されている場合、オブジェクトの名前を変更するたびに、少なくとも2つの変更が発生します。1つは名前を変えられたオブジェクトの変更、もう1つはそのオブジェクトの翻訳を定義しているすべてのカルチャの変更です。翻訳されたオブジェクトの翻訳をシリアライズする**にチェックを入れると、オブジェクト名が変更されるだけで、そのオブジェクトには翻訳された値も含まれます（この情報はアノテーションとして保存されるからです）。

### 直列化の深さ

チェックリストでは、どのオブジェクトを個別のファイルとしてシリアル化するかを指定できます。なお、上記の設定によっては、一部のオプション（パースペクティブ、翻訳、リレーションシップ）が利用できない場合があります。

ほとんどの場合、オブジェクトを常に最下位レベルまでシリアル化することが推奨されます。しかし、このレベルの詳細が必要ない特別なケースがあるかもしれません。

## Power BIとバージョン管理

前述したように、Power BIレポート(`.pbix`)やPower BIテンプレート(`.pbit`)ファイルをバージョンコントロールに統合しても、これらのファイルがバイナリファイル形式を使用しているため、並行開発やコンフリクト解決ができません。同時に、Power BI DesktopやPower BI XMLAエンドポイントでTabular Editor（または他のサードパーティツール）をそれぞれ使用する際には、現状では制限があることを認識する必要があります。

複数の制限があります。

- Power BI Desktopの外部ツールとしてTabular Editorを使用する場合、[すべてのモデリング操作がサポートされているわけではありません](@xref:desktop-limitations)。
- Tabular Editorは、Power BI Desktopで読み込まれた`.pbix`ファイル、またはディスク上の`.pbit`ファイルから直接モデルのメタデータを抽出できますが、Power BI Desktopの外部で`.pbix`または`.pbit`ファイルのモデルメタデータを更新する方法は**サポートされていません**。
- XMLAエンドポイントを通じてPower BIデータセットに何らかの変更を加えると、[そのデータセットは`.pbix`ファイルとしてダウンロードできなくなる](https://docs.microsoft.com/en-us/power-bi/admin/service-premium-connect-tools#power-bi-desktop-authored-datasets)。

並行開発を可能にするためには、モデルのメタデータを上記のテキストベース（JSON）のフォーマット（Model.bimまたはDatabase.json）のいずれかで保存できるようにする必要があります。テキストベースのフォーマットから`.pbix`や`.pbit`ファイルを「再現」する方法はありませんので、**このルートを選択した場合、Power BI Desktopを使ってデータモデルを編集することはできなくなります**。代わりに、JSONベースのフォーマットを使用できるツールに頼らなければなりませんが、これこそがTabular Editorの目的です。

> [警告]Power BI Premium ワークスペース（Premium capacity または Premium-Per-User）にアクセスできない場合、JSON ファイルに格納されたモデルのメタデータを公開できません。この操作には [XMLA エンドポイント](https://docs.microsoft.com/en-us/power-bi/admin/service-premium-connect-tools) へのアクセスが必要だからです。
> レポートのビジュアル部分を作成するためには、Power BI Desktopが必要となります。レポートをモデルから切り離すことは、[ベストプラクティスです](https://docs.microsoft.com/en-us/power-bi/guidance/report-separate-from-model)。両方を含む既存のPower> BIファイルがある場合、[このブログ記事](https://powerbi.tips/2020/06/split-an-existing-power-bi-file-into-a-model-and-report/) ([ビデオ](https://www.youtube.com/watch?v=PlrtBm9YN_Q))では、モデルファイルとレポートファイルに分割する方法を説明しています。

## Tabular Editorとgit

Gitはフリーでオープンソースの分散型バージョン管理システムで、小規模なプロジェクトから大規模なプロジェクトまで、あらゆるプロジェクトを迅速かつ効率的な処理ができるように設計されています。現在もっとも普及しているバージョンコントロールシステムで、[Azure DevOps](https://azure.microsoft.com/en-us/services/devops/repos/)、[GitHub](https://github.com/)、[GitLab](https://about.gitlab.com/)など、複数のホスティングオプションで利用できます。

この記事では、gitの詳細については触れません。しかし、もっと詳しく知りたい方は、オンラインで多くの資料を入手できます。参考までに[Pro Git](https://git-scm.com/book/en/v2)という本をオススメします。

> [!!! 注意]
> Tabular Editor 3は現在、gitや他のバージョンコントロールシステムとの統合を行っていません。gitリポジトリの管理、コード変更のコミット、ブランチの作成などを行うには、gitコマンドラインや、[Visual Studio Team Explorer](https://docs.microsoft.com/en-us/azure/devops/user-guide/work-team-explorer?view=azure-devops#git-version-control-and-repository)や[TortoiseGit](https://tortoisegit.org/)などの別のツールを使用する必要があります。
前述の通り、モデルのメタデータをgitコードリポジトリに保存する際には、Tabular Editorの[Save to Folder](#what-is-save-to-folder)オプションを使用することをお勧めします。

## 分岐戦略（Branching strategy）

以下では、タブラーモデルを開発する際に採用する分岐戦略について説明します。

分岐戦略は、日々の開発ワークフローを決定するものであり、多くの場合、分岐はチームが使用するプロジェクトメソッドに直接結びつきます。たとえば、[Azure DevOpsにおけるアジャイルプロセス](https://docs.microsoft.com/en-us/azure/devops/boards/work-items/guidance/agile-process-workflow?view=azure-devops)を使用した場合、バックログは、**絵**、**特徴**、**ユーザーストーリー**、**タスク**、**バグ**で構成されます。

アジャイル用語では、**ユーザーストーリー**は、成果物であり、テスト可能な作品のことです。ユーザーストーリーは、いくつかの**タスク**で構成されている場合があります。**タスク**は、ユーザーストーリーを納品する前に、通常は開発者が実行する必要のある、より小さな作業です。理想的な世界では、すべてのユーザーストーリーが管理可能なタスクに分割され、それぞれのタスクは数時間で完了し、ユーザーストーリー全体では数日しかかかりません。このようなユーザーストーリーは、いわゆるトピックブランチの理想的な候補となり、開発者はユーザーストーリー内の各タスクに対して1つまたは複数のコミットを行うことができます。すべてのタスクが完了したら、ユーザーストーリーをクライアントに納品します。このとき、トピックブランチは納品用のブランチ (たとえば「Test」ブランチ) にマージされ、コードはテスト環境にデプロイされます。

適切なブランチ戦略を決定するには、さまざまな要因があります。一般的にMicrosoftは、アジャイルで小刻みに継続的な配信をするために、[Trunk-based Development](https://docs.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance?view=azure-devops) ([video](https://youtu.be/t_4lLR6F_yk?t=232))という戦略を推奨しています。主なアイデアは、新機能やバグフィックスごとに「Main」ブランチからブランチを作成することです（以下の画像を参照）。コードレビューのプロセスは、機能ブランチからMainへのプルリクエストを通じて実施され、Azure DevOpsのBranch Policy機能を使って、プルリクエストが完了する前にコードがきれいにビルドされることを要求するルールを設定できます。

![トランクベース開発](https://docs.tabulareditor.com/images/trunk-based-development.png)

### トランクベース開発

しかし、ビジネスインテリジェンスの開発チームでは、いくつかの理由から、このような戦略は実行できないかもしれません。

- 新機能の開発には、ビジネスユーザーによるテストや検証が必要になることが多く、完了までに数週間を要することがあります。新しい機能は、ビジネスユーザによる長期間のテストと検証を必要とすることが多く、完成までに数週間かかることもあります。
- BIソリューションは多層構造になっており、通常、ETLを備えたデータウェアハウス層、マスターデータ管理層、セマンティック層、レポートなどで構成されています。これらの層の間には依存関係が存在し、テストと展開をさらに複雑にしています。
- BIチームは、ビジネスのさまざまな分野（販売、在庫、物流、財務、人事など）に対応する、成熟度や開発ペースが異なる複数の異なるセマンティックモデルの開発および保守を担当する場合があります。
- BIソリューションのもっとも重要な側面はデータです。BI開発者は、ソースコントロールからコードをチェックアウトしてF5キーを押すだけで、コードをコンパイルするのに必要な数分で完全なソリューションを実行できるような贅沢はできません。ソリューションにはデータが必要であり、そのデータをロードしたり、ETLしたり、複数のレイヤーで処理をしたりエンドユーザに提供する必要があります。DevOpsのワークフローにデータを含めると、構築やデプロイにかかる時間が数分から数時間、さらには数日にまで短縮されます。場合によっては、リソースや経済的な制約のために、それができないこともあります。

BIチームが、BIソリューション全体のどのレイヤーでも並行して開発をサポートし、テスト準備が整った機能を組み合わせられるようなブランチ戦略から恩恵を受けることは間違いありません。しかし、とくに上記の最後の箇条書きにより、データをどのように処理するかを注意深く考える必要があります。たとえば、ディメンションに新しい属性を追加した場合、ビルドやデプロイメントのパイプラインの一部としてディメンションを自動的にロードするのか？そのようなディメンションのロードに数分しかかからないのであれば問題ないでしょうが、数十億行のファクトテーブルに新しいカラムを追加する場合はどうでしょうか。また、開発者が新機能の開発を並行して行っている場合、各開発者は独自の開発データベースを持つべきなのか、それとも共有データベースでお互いの足を踏まないようにするにはどうすればよいのか。

とくに、BIソリューションのすべての階層や、地球上のBIチームの異なる配置や好みのワークフローを考慮すると、上記の質問に対する簡単な答えはありません。また、実際の構築、展開、テストの自動化については、主にAnalysis Servicesに焦点を当てることになります。ETL層やデータベース層には、DevOpsの観点から独自の課題がありますが、それについてはこの記事の範囲外です。しかし、先に進む前には、別のブランチ戦略と、それがどのようにBIワークフローに採用される可能性があるかを見てみましょう。

### GitFlowの分岐と展開環境

以下で説明する戦略は、[GitFlow by Vincent Driessen](https://nvie.com/posts/a-successful-git-branching-model/)をベースにしています。

![Gitflow](https://docs.tabulareditor.com/images/gitflow.png)

このようなブランチ戦略を導入することで、ブランチとデプロイ環境の関連性を考慮すれば、BIチームが直面するDevOpsの問題を解決できます。理想的な世界では、GitFlowを完全にサポートするためには、少なくとも4つの異なる環境が必要です。

- **プロダクション**環境。masterブランチのHEADにあるコードが常に含まれている必要があります。
- 開発ブランチのHEADに常にコードが含まれているべき **予備** 環境。ここでは、毎晩のデプロイメントをスケジュールしたり、統合テストを実行したりして、本番環境への次のリリースで使用する機能がうまく動作することを確認します。
- 1つまたは複数の **UAT** 環境で、ユーザーとビジネスユーザーが新機能のテストと検証を行います。デプロイメントは、テストする必要のあるコードを含む機能ブランチから直接行われます。複数の新機能を並行してテストしたい場合は、複数のテスト環境が必要になります。BI層間の依存関係を慎重に考慮すれば、多少の調整作業を経て、通常は1つのテスト環境で十分です。
- 上記の環境に影響を与えることなく新機能を開発できる、1つまたは複数の**サンドボックス**環境。テスト環境と同様に、通常は1つの共有サンドボックス環境があれば十分です。

ここで強調しておきたいのは、これらの検討事項に対する「万能のソリューション」は実際には存在しないということです。たとえば、クラウドでソリューションを構築していない場合、数秒から数分で新しいリソースを立ち上げるようなスケーラビリティや柔軟性はありません。あるいは、データボリュームが非常に大きく、リソース、経済性、時間の制約から環境を複製することが現実的ではない場合もあります。次の段階に進む前に、本当に並列開発やテストをサポートする必要があるのかどうかを自問してみてください。ステークホルダーが数人しかいない小規模なチームの場合は、CI/CDの恩恵を受けることはできてもGitFlowのブランチ機能は過剰になる可能性があり、そのようなケースはほとんどありません。

並行開発をサポートする必要がある場合でも、複数の開発者が同じ開発環境やサンドボックス環境を共有するのは簡単で、それほど大きな問題は発生しないでしょう。とくに表形式のモデルについては、「お互いの足を引っ張らない」ように、開発者は個別の [ワークスペース・データベース](xref:workspace-mode) を使うことをオススメします。

## 一般的なワークフロー

すでにgitリポジトリがセットアップされていて、ブランチ戦略に沿っているとすれば、タブラーモデルの「ソースコード」をリポジトリに追加するには、Tabular Editorを使ってメタデータをローカルリポジトリの新しいブランチに保存するだけで済みます。次に、新しいファイルをステージングしてコミットし、ブランチをリモートリポジトリにプッシュし、プルリクエストを作成してブランチをメインブランチにマージします。

正確なワークフローは、あなたのブランチ戦略やgitリポジトリの設定に依存します。一般的には、以下のような流れになります。

1. 新しい機能の開発を始める前に、gitで新しい機能ブランチを作成します。トランクベースの開発シナリオでは、次のようなgitコマンドでメインブランチをチェックアウトして最新版のコードを取得し、そこから機能ブランチを作成します。

```cmd
git checkout main
git pull
git checkout -b "feature\AddTaxCalculation"
```

1. ローカルのgitリポジトリからモデルのメタデータをTabular Editorで開きます。理想的には、[workspace database](xref:workspace-mode)を使うと、DAXコードのテストやデバッグがしやすくなります。
2. Tabular Editorを使用して、モデルに必要な変更を加えます。変更を継続的に保存します(CTRL+S)。コードの変更を保存した後、定期的にgitにコミットすることで、作業のロスを防ぎ、変更したすべての履歴を残すことができます。

```cmd
git add .
git commit -m "Description of what was changed and why since last commit"
git push
```

3. ワークスペースデータベースを使用していない場合は、Tabular Editorの**Model > Deploy...** オプションを使用して、サンドボックス/開発環境にデプロイし、モデルのメタデータに加えられた変更をテストします。
4. 完了し、すべてのコードがコミットされてリモートリポジトリにプッシュされたら、メインブランチにコードを統合するためにプルリクエストを送信します。マージの際にコンフリクトが発生した場合は、ローカルで解決する必要があります。Visual Studio Team Explorer を使ったり、.json ファイルをテキストエディタで開いてコンフリクトを解決したりします (git はコンフリクトマーカーを挿入して、コードのどの部分にコンフリクトがあるかを示します)。
5. すべてのコンフリクトが解決したら、コードレビューやブランチポリシーに基づく自動ビルド/テストの実行などのプロセスを経てプルリクエストを完了させることができます。ただし、これはブランチ戦略と全体的な設定に依存します。

以下の記事では、Azure DevOpsを使って、gitブランチポリシーの設定、自動ビルドやデプロイメントパイプラインの設定などの詳細を紹介しています。同様の手法は、TeamCityやGitHubなど、他の自動ビルド環境やgitホスティング環境でも使用できます。

# 次のステップ

- パワポケCICD
- @as-cicd
- ワークスペースモードの最適化
